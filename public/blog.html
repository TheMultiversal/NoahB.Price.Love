<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blog - Noah B. Price</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="global.css">
  <style>.hero h1 { margin-bottom:2rem; }</style>
  <script src="/particles.min.js"></script>
  <script src="/background-init.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@hotwired/turbo@7.3.0/dist/turbo.min.js"></script>
  <script src="/nav.js"></script>
  <script src="/particles-mouse.js"></script>
  <script>(function(){
  // Initialize only when DOM is ready (prevents errors when scripts run in <head>)
  function _ready(fn){
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', fn);
    } else { fn(); }
    document.addEventListener('turbo:load', fn);
  }

  _ready(function(){
    const AUDIO_BASENAME = '/uploads/site-music'; // try .mp3 first, then .m4a
    const STORAGE_KEY = 'siteAudioState';
    // Resolve available extension (.mp3 or .m4a) by probing the server once per page load
    let AUDIO_EXT = '.mp3';
    async function _detectAudioExt(){
      try{
        const res = await fetch(AUDIO_BASENAME + '.mp3', { method: 'HEAD' });
        if(res && res.ok) return '.mp3';
        const res2 = await fetch(AUDIO_BASENAME + '.m4a', { method: 'HEAD' });
        if(res2 && res2.ok) return '.m4a';
      }catch(e){}
      return '.mp3'; // fallback to .mp3 by default
    }
    function _audioSrc(){ const cb = _getCacheBuster(); return AUDIO_BASENAME + AUDIO_EXT + (cb ? '?cb=' + cb : ''); }

  // Reuse a persistent audio element if present (Turbo permanent). Create only if missing.
  let audio = document.getElementById('site-audio');
  const createdHere = !audio;

  // Helper to read a cache-buster set after upload so clients fetch the newest file
  function _getCacheBuster(){ try{ return localStorage.getItem('siteAudioCacheBuster') || ''; }catch(e){ return ''; } }
  // Resolve the current audio URL (basename + detected extension + cache-buster)
  function _audioSrc(){ const cb = _getCacheBuster(); return AUDIO_BASENAME + AUDIO_EXT + (cb ? '?cb=' + cb : ''); }

  // Ensure we detect which extension to use, then create or update the audio element
  _detectAudioExt().then(ext => {
    AUDIO_EXT = ext;
    if(!audio){
      audio = document.createElement('audio');
      audio.id = 'site-audio';
      audio.src = _audioSrc();
      audio.loop = true;
      audio.preload = 'auto';
      audio.crossOrigin = 'anonymous';
      audio.style.display = 'none';
      audio.volume = 0.9;
      // mobile-friendly attributes
      try{ audio.setAttribute('playsinline',''); audio.setAttribute('webkit-playsinline',''); audio.playsInline = true; }catch(e){}
      document.body.appendChild(audio);
    } else {
      // Ensure src points to the uploaded file (with cache-bust)
      const desiredSrc = _audioSrc();
      // compare only the path+query portion so that absolute vs relative mismatch doesn't trigger reload
      const current = audio.src ? new URL(audio.src, window.location.href).pathname + new URL(audio.src, window.location.href).search : '';
      const want = new URL(desiredSrc, window.location.href).pathname + new URL(desiredSrc, window.location.href).search;
      if(!current || current.indexOf(AUDIO_BASENAME) === -1 || current !== want){
        audio.src = desiredSrc;
        try{ audio.load(); }catch(e){}
      }
    }

    // If audio fails to load (extension mismatch), try the other known extension once
    audio.addEventListener('error', function onAudioError(){
      if(AUDIO_EXT === '.mp3'){
        AUDIO_EXT = '.m4a';
        audio.src = _audioSrc();
        try{ audio.load(); }catch(e){}
      }
      audio.removeEventListener('error', onAudioError);
    });
  }).catch(()=>{
    // If detection fails, proceed with default src already set above
  });

  // Ask server for the current audio file version (mtime) and update cache-buster automatically
  (function(){
    fetch('/audio-version').then(r => r.json()).then(j => {
      if(j && j.version){
        try{
          const sv = String(j.version);
          const local = String(localStorage.getItem('siteAudioCacheBuster') || '');
          if(local !== sv){
            localStorage.setItem('siteAudioCacheBuster', sv);
            const newSrc = _audioSrc();
            // avoid reload if only absolute/relative difference
            const cur = audio.src ? new URL(audio.src, window.location.href).pathname + new URL(audio.src, window.location.href).search : '';
            const want = new URL(newSrc, window.location.href).pathname + new URL(newSrc, window.location.href).search;
            if(cur !== want){
              audio.src = newSrc;
              try{ audio.load(); }catch(e){}
            }
          }
        }catch(e){}
      }
    }).catch(()=>{});
  })();

  // Helper to resume playback/unmute based on saved state. Non-blocking and tolerant of autoplay policies.
  function resumeIfNeeded(){
    try{
      const s = localStorage.getItem(STORAGE_KEY);
      if(!s) return;
      const st = JSON.parse(s);
      // Restore unmuted preference immediately if user previously unmuted
      if(st.unmuted){
        try{ audio.muted = false; }catch(e){}
      }
      // Restore time if needed
      try{ if(typeof st.time === 'number' && !isNaN(st.time)) audio.currentTime = st.time; }catch(e){}
      // If previously playing, try to play (may be blocked by browser if no gesture; that's fine)
      if(st.playing){
        audio.play().then(()=>{
          // playing resumed
          saveState();
          _updateCtlIcon();
        }).catch(()=>{
          // Could not autoplay (likely blocked) â€” leave state and control for user interaction
          _updateCtlIcon();
        });
      } else {
        _updateCtlIcon();
      }
    }catch(e){ console.warn('[AudioPlayer] resumeIfNeeded failed', e); }
  }

  // If this audio element has already been initialized, avoid reattaching event listeners
  if(audio.dataset.siteAudioInitialized === '1'){
    // On re-run (new page), ensure saved desired state is respected (resume if needed)
    resumeIfNeeded();
    return;
  }

  // Also ensure we attempt resume on Turbo navigations
  document.addEventListener('turbo:load', function(){ resumeIfNeeded(); });

  audio.dataset.siteAudioInitialized = '1';

  // Floating control (visible & interactive) â€” allows users to play/unmute immediately
  const ctl = document.createElement('button');

  // Prompt overlay shown until first interaction; persuades user to scroll/click for sound
  const prompt = document.createElement('div');
  prompt.id = 'audio-start-prompt';
  prompt.textContent = 'Scroll or tap anywhere to hear music';
  Object.assign(prompt.style, {
    position: 'fixed',
    top: '0',
    left: '0',
    right: '0',
    padding: '12px',
    background: 'rgba(0,0,0,0.7)',
    color: '#fff',
    textAlign: 'center',
    fontSize: '16px',
    zIndex: 2001,
    cursor: 'pointer'
  });
  document.body.appendChild(prompt);

  function hidePrompt(){
    if(prompt && prompt.parentNode) prompt.parentNode.removeChild(prompt);
  }

  startOnGesture = (function(orig){
    return function(e){
      hidePrompt();
      orig(e);
    };
  })(startOnGesture);

  ctl.id = 'site-audio-control';
  ctl.setAttribute('aria-label','Play or pause site audio');
  ctl.title = 'Play / Pause site audio';
  ctl.innerHTML = 'ðŸ”ˆ';
  Object.assign(ctl.style, {
    position: 'fixed',
    right: '16px',
    bottom: '16px',
    zIndex: 2000,
    width: '44px',
    height: '44px',
    borderRadius: '50%',
    border: 'none',
    background: '#2c3e50',
    color: '#fff',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '18px',
    boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
    opacity: '0.95',
    pointerEvents: 'auto'
  });
  document.body.appendChild(ctl);

  // Update button icon/text based on state
  function _updateCtlIcon(){
    try{
      if(audio.paused){
        ctl.innerHTML = 'âµ'; // play
        ctl.title = 'Play site audio';
      } else if(audio.muted){
        ctl.innerHTML = 'ðŸ”ˆ'; // muted
        ctl.title = 'Unmute site audio';
      } else {
        ctl.innerHTML = 'ðŸ”Š'; // playing & unmuted
        ctl.title = 'Pause site audio';
      }
    }catch(e){}
  }

  // Toggle behaviour: click toggles play/pause and unmutes if muted
  ctl.addEventListener('click', function(e){
    e.preventDefault();
    try{
      if(audio.muted){
        audio.muted = false;
        saveState();
      }
      if(audio.paused){
        audio.play().then(()=>{ saveState(); _updateCtlIcon(); }).catch(()=>{ _updateCtlIcon(); });
      } else {
        audio.pause();
        saveState();
        _updateCtlIcon();
      }
    }catch(err){
      console.error('[AudioPlayer] Control click error', err);
    }
  });

  // Update icon on audio events
  audio.addEventListener('play', _updateCtlIcon);
  audio.addEventListener('pause', _updateCtlIcon);
  audio.addEventListener('volumechange', _updateCtlIcon);

  // Load saved state (includes unmuted preference)
  let state = { playing: false, time: 0, unmuted: false };
  try{ const s = localStorage.getItem(STORAGE_KEY); if(s) state = JSON.parse(s); } catch(e){}

  // Apply stored time only if we created the element here and time is available
  if(createdHere && state.time){
    try{ audio.currentTime = state.time || 0; }catch(e){}
  }

  // Apply mute/unmute preference: default to muted unless user previously unmuted
  try{
    if(state.unmuted){ audio.muted = false; } else { audio.muted = true; }
  }catch(e){}

  function saveState(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({ playing: !audio.paused, time: audio.currentTime, unmuted: !audio.muted })); }catch(e){}
  }

  // Try autoplay quietly on load (muted autoplay is generally allowed)
  function tryAutoPlay(){
    audio.play().then(()=>{ saveState(); }).catch(()=>{});
  }

  // Fade-in helper: ramp volume from current to target over ms
  function _fadeVolume(to, ms){
    try{
      var start = audio.volume;
      var startT = Date.now();
      if(ms <= 0){ audio.volume = to; return; }
      function step(){
        var t = (Date.now() - startT) / ms;
        if(t >= 1){ audio.volume = to; return; }
        audio.volume = start + (to - start) * t;
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }catch(e){}
  }

  // Start playback and unmute on first meaningful user interaction (click, touchstart, keydown, wheel, touchmove)
  function startOnGesture(){
    try{
      // Unmute on first gesture if muted â€” apply soft fade-in
      if(audio.muted){
        audio.muted = false;
        var target = 0.9;
        try{ audio.volume = 0; }catch(e){}
        saveState();
        audio.play().then(()=>{ _fadeVolume(target, 800); saveState(); }).catch(()=>{/* still blocked */});
      } else {
        audio.play().then(()=>{ saveState(); }).catch(()=>{/* still blocked */});
      }
    }catch(e){}
  }

  // include scroll as a user interaction that should trigger playback/unmute
  ['click','touchstart','keydown','wheel','touchmove','touchend','scroll'].forEach(ev => {
    window.addEventListener(ev, startOnGesture, { once: true, passive: true });
  });

  // also hide prompt if page is scrolled programmatically or via other means
  window.addEventListener('scroll', hidePrompt, { once: true, passive: true });

  // Also attempt immediate autoplay (muted autoplay usually allowed)
  tryAutoPlay();

  // Save progress periodically and enforce a 30:00 playback window (player-limited clip)
  const CLIP_START = 0;           // clip start in seconds (user requested start)
  const CLIP_DURATION = 30 * 60;  // 30 minutes
  const CLIP_END = CLIP_START + CLIP_DURATION;

  audio.addEventListener('timeupdate', function(){
    try{
      // If we've reached the requested clip end, stop and reset to clip start
      if(typeof audio.currentTime === 'number' && audio.currentTime >= CLIP_END){
        audio.pause();
        try{ audio.currentTime = CLIP_START; }catch(e){}
        saveState();
        _updateCtlIcon();
        return;
      }
    }catch(e){ /* ignore */ }

    // throttle state saves
    if(!audio._lastSaved || (Date.now() - audio._lastSaved) > 1000){
      audio._lastSaved = Date.now();
      saveState();
    }
  });

  // On unload / before caching (Turbo) save time
  window.addEventListener('pagehide', function(){ saveState(); });
  window.addEventListener('beforeunload', function(){ saveState(); });
  document.addEventListener('turbo:before-cache', function(){ saveState(); });

  // If previously playing, try to resume
  resumeIfNeeded();
  });
})();</script>

</head>
<body>
  <div id="vanta-bg"></div>
  <header>
    <button id="nav-toggle" class="nav-toggle" aria-controls="main-nav" aria-expanded="false">â˜°</button>
    <nav>
      <ul id="main-nav" class="nav-list">
        <li><a href="/">Home</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/books">Books</a></li>
        <li><a href="/blog">Blog</a></li>
        <li><a href="/contact">Contact</a></li>
        <li><a href="/email-list">Email List</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <section class="hero">
      <h1 style="margin-bottom:3rem;">Journey into Noah's Journal</h1>
    </section>
    <section>
      <h2>Recent Writing</h2>

      <p>Not everything I examine belongs inside a finished book.</p>

      <p>Some ideas need to be addressed while they are still active.</p>

      <p>Some observations require precision<br>before they are distorted by repetition<br>or simplification.</p>

      <p>This is where I write when something deserves clarity now.</p>

      <p>The journal is not an overflow container.</p>

      <p>It is an extension of the same work, standards,<br>and refusal to speak carelessly about things that matter.</p>

      <p>Here I question assumptions in real time.</p>

      <p>I analyze what is forming beneath the surface of culture.</p>

      <p>I articulate thoughts before they calcify into accepted narratives.</p>

      <p>I do not write here for reaction.</p>

      <p>I write here because certain things require articulation.</p>

      <p>If a piece lingers with you after you leave,<br>it is because it named something you already sensed<br>but had not yet defined.</p>
    </section>
    <section>
      <h2>What You Will Find Here</h2>

      <p>This journal is where I examine the act of paying attention itself.</p>

      <p>You will find reflections on writing,<br>but more importantly on perception.</p>

      <p>Observations drawn directly from lived experience,<br>without insulation.</p>

      <p>Explorations of belief, responsibility,<br>and the structures that shape how we see the world.</p>

      <p>You will find context behind developing work,<br>and the questions that drive it before it reaches the page<br>in finished form.</p>

      <p>Some entries are brief because the insight is exact.</p>

      <p>Others unfold gradually because the subject requires depth.</p>

      <p>All of it is written with discipline<br>and respect for your time<br>and intelligence.</p>
    </section>
    <section>
      <h2>Recent Entries</h2>
      <p>Below are the most recent pieces. You can begin anywhere. There is no correct order, only what draws your attention now.</p>
      <p>Each entry stands on its own, while remaining in conversation with the rest.</p>
      <a href="/latest-entry" class="btn">Read the Latest Entry</a>
      <a href="/all-journals" class="btn">Explore all journals</a>
    </section>
    <section>
      <h2>An Invitation to Engage</h2>
      <p>You are not asked to agree with what you encounter here.</p>
      <p>You are asked to read attentively.</p>
      <p>If something clarifies a thought you have carried, unsettles an assumption, or names an experience you have not yet put into words, then the writing has done what it was meant to do. Reflection does not require alignment. It requires presence.</p>
    </section>
    <section>
      <h2>Stay Connected</h2>
      <p>If you would like to receive new entries, personal notes, or updates on ongoing work, you are welcome to join the mailing list. It is the most direct way to remain connected as the writing continues.</p>
      <p>No excess. No noise.<br>Only what is worth sharing.</p>
      <p>â†’ <a href="/contact">Join the Mailing List</a></p>
    </section>
  </main>
  <footer>
    <div>
      <h3>Stay Connected</h3>
      <p>Private notes and updates are shared through the mailing list.</p>
      <p><a href="/email-list">&rarr; Join the Mailing List</a></p>
      <p>Books by Noah B. Price are available on Amazon.</p>
      <p><a href="https://amazon.com">&rarr; Buy on Amazon</a></p>
    </div>
    <div>
      <h3>Legal</h3>
      <p><a href="/privacy">Privacy Policy</a></p>
      <p><a href="/terms">Terms of Use</a></p>
      <p><a href="/accessibility">Accessibility</a></p>
    </div>
    <p>&copy; 2026 Noah B. Price. All rights reserved.</p>
  </footer>
</body>
</html>